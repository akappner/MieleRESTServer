#[allow(dead_code)]
use crate::*;
use crate::payloader::device::generic::state::cs_context::{CSContext, CSContextParametersWasher};
use crate::payloader::helper::types::{AnnotatedBool, GenericU8, GenericU16};
use crate::payloader::device::generic::program_selection::enums::ProgramIdOven;
use crate::payloader::prelude::ValueInterpretation;
// Static test data structure with individual fields
struct TestPayloads {
    oven_14_130: &'static str,
    oven_2_1586: &'static str,
    oven_9_19: &'static str,
    oven_ident: &'static str,
    oven_2_114: &'static str,
    oven_1_391: &'static str,
    oven_1_209: &'static str,
    oven_2_1585: &'static str,
    oven_1_1599: &'static str,
    washer_1_154: &'static str,
    synthetic_garbage_missing_field: &'static str,
    synthetic_garbage_invalid_boolean: &'static str,
}

static TEST_PAYLOADS: TestPayloads = TestPayloads {
    // actual oven payloads
    oven_14_130:"000e000e008200010001000100010400", // one E8, no padding
    oven_2_1586: "0016000206320000000000030001040400020405000304012020202020202020", // devicecombistate, 3 E8, padding
    oven_9_19: "00230009001300000001000500010500ab0002050001000305fb00000405fb0000050500002020202020202020202020", // U16s with padding
//001c000e007a00010001000200010b0000000068e814fd000209000000002020 //Unsigned64
    oven_ident: "004e000e061d0001000100080002040000030400000412000530392e31340005051a390006120008001d63fffeaf152f0007040000081200080000000000000000000914000a00000000000000000000",
    oven_2_114: "009f0002007200000000000200010226000217004603f903f303fa03ee03f1001e0021001b001c001d001a000a000b000c00150018001903e800030005000400160011000e0012042e042d04590464045a046b046904520453046504560457046c00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000202020202020202020202020202020",
    oven_1_391: "02c1000101870000000000090001100003000104000002040000030400000710001a0001070000000207000000031000030001020000020500000003040000041000030001020000020500000003040000051000030001020000020500000003040000061000030001020000020500000003040000071000030001020000020500000003040000081000030001020000020200000304000009100003000102000002020000030400000a0400000b0200000c100003000102000002020000030400000d100003000102000002020000030400000e10000300010200000202000003040000100400001210000300010200000205000000030400001308000000000014070000001510000300010200000205000000030400001610000300010200000202000003040000171000030001020000020500000003040000181000030001020000020200000304000019100003000102000002020000030400001a1000030001020000020b000000000000000000030400001c070000001d1000030001020000020b000000000000000000030400000810001e000208000000000003080000000000040800000000000508000000000006080000000000070400000804000009100003000104000002040000030400000b0400000c050000000d0800000000000e0800000000000f0200001004000011040000120100001301000014010000150100001608000000000017050000001805000000190200001a0100001b0100001c0100001d050000001e050000001f100003000101000002010000030100002010000400010100000201000003010000040100000917000e00000000000000000000000000000000000000000000000000000000000a0400000b0100000c070000000d0100001110000700010100000208000000000003080000000000040800000000000512000c00000000000000000000000000060500000007080000000020202020202020202020202020", // struct with U8s
    oven_1_209: "0050000100d1000000000002000121000200020001010000020b000000000000000000020001010000020b000000000000000000022100020002000104000002090000015c000200010401000209000000002020202020202020202020202020", // Struct[]
    oven_2_1585: "02c1000106310000000000090001100003000104040002040600030404000710001a00010727100002070000000310000300010200000205ffff00030400000410000300010208000205000000030405000510000300010200000205ffff00030405000610000300010208000205086300030403000710000300010200000205ffff0003040300081000030001020800020201000304000009100003000102000002020000030400000a0432000b0200000c100003000102000002020000030400000d100003000102000002020000030400000e100003000102000002020000030400001004000012100003000102000002050000000304000013080000000000140700000015100003000102080002053e8000030403001610000300010200000202000003040100171000030001020000020500000003040300181000030001020000020200000304000019100003000102000002020000030407001a1000030001020800020b0000000068e814f40003041f001c07000d001d1000030001020000020b000000000000000000030400000810001e000208000000000003080000000000040800000000000508000000000006080000000000070400000804000009100003000104000002040000030400000b0400000c05ffff000d0800000000000e0800000000000f02ff001004000011040000120100001301000014010000150100001608000001630017050000001805000000190200001a0100001b0100001c0100001d050000001e050000001f100003000101000002010000030100002010000400010100000201000003010000040100000917000e0013000e000200380070000000000000000000000000000000000000000a0401000b0101000c070000000d0100001110000700010100000208ffffffff00030800000000000408ffffffff000512000c0000000000000000000000000006050000000708ffffffff20202020202020202020202020",
    oven_1_1599: "026c0001063f00000000000620001210008000400010500010002050060000308000000010004180004518036610007800000000000000000000004000105006100020500960003080000000200041800040000000000000000000000000000000000040001053a980002053ab7000308000001000004180004000000010000000000000000000000000004000105010300020501420003080000001000041800045e40d8110000000000000000000000000004000105014300020501620003080000002000041800040000301f00000000000000000000000000040001053e800002053edf0003080000020000041800042bdfdf0e0000003f0000000000000000000400010500000002050000000308000000000004180004000000000000000000000000000000000004000105000000020500000003080000000000041800040000000000000000000000000000000000022100010004000105016300020507e0000308000000400004180040f99c76ae11f8c681c103071b0001643cefffe308513ffcbb000007fe0000000003807c00000000000ff0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002020", // programGroupsComplete
    washer_1_154: "00d40002009a0000000000020001070000000210000800011000030001020900020100000304000002100006000102000002050000000305000000040500000005050000000604000003100006000102000002020000030200000402000005020000060400000410000600010200000205000000030500000004050000000505000000060400000510000600010200000202000003020000040200000502000006040000061000030001020000020100000304000007100003000102000002010000030400000810000300010200000201000003040020202020202020202020",
    synthetic_garbage_missing_field: "0016000206320000000000030001040400020405000304012020202020202020",
    synthetic_garbage_invalid_boolean: "000e000e0082000100010001000101FF"
};
 static TEST_BANK : [&str; 7] = [TEST_PAYLOADS.oven_14_130, TEST_PAYLOADS.oven_2_1586, TEST_PAYLOADS.oven_9_19, TEST_PAYLOADS.oven_ident, TEST_PAYLOADS.oven_2_114, TEST_PAYLOADS.oven_1_391, TEST_PAYLOADS.oven_1_209];
#[test]
 fn test_synthetic_garbage_invalid_boolean() {
    let mut parser = Dop2Parser::new(hex::decode(TEST_PAYLOADS.synthetic_garbage_invalid_boolean).unwrap());
    let result = RootNode::parse(&mut parser);
    assert!(result.is_err());
 }
#[test]
 fn test_synthetic_garbage_missing_field() {
    let mut parser = Dop2Parser::new(hex::decode(TEST_PAYLOADS.synthetic_garbage_missing_field).unwrap());
    let result = RootNode::parse(&mut parser);
    let root_node = result.unwrap();
    let context = CSContext::try_from(root_node.root_struct.clone());
    assert!(context.is_err());
 }
#[test]
fn test_root_node_parse_insufficient_data() {
    // Test with insufficient data (only 2 bytes, need at least 4)
    let test_data = vec![0x12, 0x34];
    
    let mut parser = Dop2Parser::new(test_data);
    let result = RootNode::parse(&mut parser);
    assert!(result.is_err());
}

#[test]
fn round_trips ()
{
    let test_bank = [TEST_PAYLOADS.oven_1_209];
    for x in test_bank
    {
        test_round_trip(x);
    }
}

#[test]
fn test_device_combo_state() {
    // Test that we can use it with our parser
    let mut parser = Dop2Parser::new(hex::decode(TEST_PAYLOADS.oven_2_1586).unwrap());
    let result = RootNode::parse(&mut parser);
    assert!(result.is_ok());
    let _root_node = result.unwrap();
    //assert_eq!(root_node.unit, 2);
    //assert_eq!(root_node.attribute, 1586);
   // assert_eq!(root_node.declared_fields, 3);
  //  assert_eq!(root_node.fields[0].value, 0x0082);
}

#[test]
fn test_washer_context_optionals() {
    let mut parser = Dop2Parser::new(hex::decode(TEST_PAYLOADS.washer_1_154).unwrap());
    let result = RootNode::parse(&mut parser);
    assert!(result.is_ok());
    let root_node = result.unwrap();
    let context = CSContext::try_from(root_node.root_struct.clone()).unwrap();
    
    // Create expected CSContext structure for comparison
    let expected_context = CSContext {
        program_id: ProgramIdOven::NoProgram,
        context_washer: Some(CSContextParametersWasher {
            on_off: AnnotatedBool {
                request_mask: 9,
                value: false,
                interpretation: ValueInterpretation::None,
            },
            water_level: GenericU16 {
                request_mask: 0,
                min: 0,
                max: 0,
                current: 0,
                step_size: 0,
            },
            water_inlet_way: GenericU8 {
                request_mask: 0,
                min: 0,
                max: 0,
                current: 0,
                step_size: 0,
            },
            speed: GenericU16 {
                request_mask: 0,
                min: 0,
                max: 0,
                current: 0,
                step_size: 0,
            },
            actuator_level: GenericU8 {
                request_mask: 0,
                min: 0,
                max: 0,
                current: 0,
                step_size: 0,
            },
            residual_moisture_resistance: AnnotatedBool {
                request_mask: 0,
                value: false,
                interpretation: ValueInterpretation::None,
            },
            rss_calibration: AnnotatedBool {
                request_mask: 0,
                value: false,
                interpretation: ValueInterpretation::None,
            },
            user_interface: AnnotatedBool {
                request_mask: 0,
                value: false,
                interpretation: ValueInterpretation::None,
            },
        }),
        context_oven: None,
    };
    
    // Test that the parsed CSContext matches the expected structure
    assert_eq!(context, expected_context);
    
    // Round-trip test: serialize back to bytes and verify it matches original
    let mut data: Vec<u8> = Vec::new();
    let _bytes = root_node.to_bytes(&mut data);
    let hex_string = hex::encode(&data);
    assert_eq!(hex_string, TEST_PAYLOADS.washer_1_154);
}

fn test_round_trip (payload: &str)
{
    let mut parser = Dop2Parser::new(hex::decode(payload).unwrap());
    let result = RootNode::parse(&mut parser);
    assert!(result.is_ok());
    let root_node = result.unwrap();
    let mut data :  Vec<u8> = Vec::new();
    let _bytes = root_node.to_bytes(&mut data);
    let hex_string = hex::encode(&data);
    assert_eq!(hex_string, payload);
}
#[test]
fn test_static_payloads() {
    // Test that we can use it with our parser
    let mut parser = Dop2Parser::new(hex::decode(TEST_PAYLOADS.oven_14_130).unwrap());
    let result = RootNode::parse(&mut parser);
    assert!(result.is_ok());

    let root_node = result.unwrap();
    let mut data :  Vec<u8> = Vec::new();
    //root_node.padding=None;
    let _bytes = root_node.to_bytes(&mut data);
    let hex_string = hex::encode(&data);
    assert_eq!(hex_string, TEST_PAYLOADS.oven_14_130);
}

